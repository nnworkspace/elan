# ------------------------------------------------------------------------------
# CLASSIFICATION: UNCLASSIFIED // ILLUSTRATIVE
# ------------------------------------------------------------------------------
# DISCLAIMER:
# This file is an ILLUSTRATIVE EXAMPLE of a CI/CD pipeline definition.
# It demonstrates the LOGICAL FLOW of governance enforcement and automation.
# It is NOT an executable pipeline configuration for any specific CI platform
# (e.g., Jenkins, GitLab CI, GitHub Actions) and contains NO functional logic.
# ------------------------------------------------------------------------------

pipeline:
  name: "03-evidence-and-reporting"
  description: >
    The "Notary Public". This pipeline aggregates evidence from all other pipelines,
    verifies its cryptographic chain of custody, and generates the
    Human-Readable and Auditor-Readable reports found in 70-reports/.

  trigger:
    - event: "workflow_run"
      workflows: ["02-integration-orchestration"]
      types: ["completed"]

  # ----------------------------------------------------------------------------
  # STAGE 1: CHAIN OF CUSTODY VERIFICATION
  # ----------------------------------------------------------------------------
  stage_verify_inputs:
    steps:
      - name: "Download Assurance Evidence"
        uses: "actions/download-artifact"
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: "assurance-evidence"

      - name: "Verify Evidence Integrity"
        run: |
          # Compute SHA-256 of the input JSONs
          sha256sum assurance-results.json > integrity.sum
          
          # Cross-reference with the Signed Attestation from the previous pipeline
          # (Illustrative: In a real system, we'd check a Sigstore transparency log)
          # echo "Verifying against Rekor log..."

  # ----------------------------------------------------------------------------
  # STAGE 2: SEMANTIC GENERATION (THE "DERIVATION")
  # ----------------------------------------------------------------------------
  stage_generate_reports:
    needs: ["stage_verify_inputs"]
    steps:
      - name: "Generate Traceability Matrix"
        run: |
          # Input: Source Code AST (from Gatekeeper) + Specs (40-specifications)
          # Output: 70-reports/traceability/matrix-YYYYMMDD.md
          
          ./tooling/report-generator traceability \
            --input-specs ./40-specifications \
            --input-code ./60-code \
            --template ./70-reports/_templates/matrix.j2

      - name: "Generate Assurance Statement"
        run: |
          # Input: Verified Test Results (from Orchestrator)
          # Output: 70-reports/assurance/security-risk-status.md
          
          ./tooling/report-generator assurance \
            --input-results ./assurance-results.json \
            --risk-threshold CRITICAL \
            --template ./70-reports/_templates/assurance.j2

      - name: "Generate SBOM & Dependency Risk"
        run: |
          # Input: Manifests (pom.xml, etc.)
          # Output: 70-reports/dependencies/sbom-YYYYMMDD.md
          
          ./tooling/report-generator sbom \
             --target ./60-code

  # ----------------------------------------------------------------------------
  # STAGE 3: IMMUTABLE PUBLICATION (GITOPS)
  # ----------------------------------------------------------------------------
  stage_publish:
    needs: ["stage_generate_reports"]
    steps:
      - name: "Prepend Provenance Headers"
        run: |
          # AUTOMATED GOVERNANCE:
          # Every generated file gets the _provenance.md header + SHA of inputs.
          for report in ./output/*.md; do
             cat 70-reports/_partials/_provenance.md $report > temp && mv temp $report
             echo "Generated by Pipeline 03 (Run ${{ github.run_id }})" >> $report
          done

      - name: "Commit to Repository"
        run: |
          # We commit the reports back to the repo so they adhere to the same
          # versioning lifecycle as the code they describe.
          
          git config user.name "Eurosystem Report Bot"
          git config user.email "bot@eurosystem.int"
          
          git add 70-reports/
          git commit -m "chore(report): derived evidence for run ${{ github.run_id }}"
          
          # In a real system, this push would be protected and strict.
          git push origin main

      - name: "Archive to WORM Storage (Audit)"
        run: |
          # Write-Once-Read-Many storage for regulatory retention (10 years)
          gsutil cp ./output/*.md gs://eurosystem-audit-archive-immutable/2025/12/30/
